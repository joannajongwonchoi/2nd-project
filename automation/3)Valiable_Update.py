# -*- coding: utf-8 -*-
"""변수생성-자동생성.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13HatQ4JmOmS3RTZjQipfFuR-I8UsgvUN
"""

import pymysql
import sys
from sqlalchemy import create_engine
from pmdarima.arima import ADFTest
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error
from dateutil.relativedelta import relativedelta
import datetime
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
from pmdarima.arima import auto_arima
from sqlalchemy import create_engine
import time


now = datetime.datetime.now().strftime('%R')
print('Pedicted Variables Update Start --',now)

def makedataset(df = None, column_name = None):
    df_timeseries = df.groupby('SOLDDATE').mean()[[column_name]]
    cutoff = round(len(df_timeseries) * 0.8)
    train = df_timeseries[:cutoff]
    test = df_timeseries[cutoff:]
    return df_timeseries, train, test

def adf_test(df_timeseries = None):
    adf_test = ADFTest(alpha=0.05)
    p, bool = adf_test.should_diff(df_timeseries)
    return bool

# 평가지표 사용자 함수
# def get_score(y_true, y_pred):
#     mae = mean_absolute_error(y_true, y_pred)
#     mse = mean_squared_error(y_true, y_pred)
#     rmse = mean_squared_error(y_true, y_pred, squared = False)
#     r2 = r2_score(y_true, y_pred)

#     print('mae :', mae)
#     print('mse :', mse)
#     print('rmse :', rmse)
#     print('r2_score :', r2)

# 한단계씩 예측
def forecast_one_step(model):
    fc = model.predict(n_periods=1)
    return fc.tolist()[0]

def set_model_evaluate(train = None ,test = None, adf_result = True):
    # if adf_result == True:
    #     model = auto_arima(train, start_p = 0, start_q = 0, max_p = 3, max_d = 3, max_q = 3, 
    #                 trace=False, stepwise = True, m = 1, seasonal=False, random_state=0, n_fits=50)
    # else:
    #     model = auto_arima(train, start_p = 0, start_q = 0, max_p = 3, max_d = 3, max_q = 3, start_P = 0, start_Q = 0,
    #                 max_P = 3, max_D = 3, max_Q = 3, trace=False, stepwise = True, m = 12, seasonal=True, random_state=0, n_fits=50)

    # 위처럼 하는게 맞으나, 언급하였듯 계절은 어느정도 정상성을 가지므로 밑처럼 하도록 하겠습니다.
    print('fitting model...')
    model = auto_arima(train, start_p = 0, start_q = 0, max_p = 3, max_d = 3, max_q = 3, 
                    trace=False, stepwise = True, m = 1, seasonal=False, random_state=0, n_fits=50)
    # y_pred = []
    # for new_ob in test.values:
    #     fc = forecast_one_step(model)
    #     y_pred.append(fc)

    #     ## 모형 업데이트
    #     model.update(new_ob[0])
    # pred_new = pd.DataFrame(y_pred,index=test.index - datetime.timedelta(1),columns=['pred'])
    #get_score(test[:-1],pred_new[1:])
    return model
    
# 날짜 데이터 프레임을 만드는 함수. 인수는 datetime 형식이어야 함
def get_date(startdate = None, enddate=None): 
    date = startdate

    li = []
    stop = 0
    stop_year = date.year + 1
    while stop == 0:
        li.append(date)
        date = date + datetime.timedelta(days=1)
        if date.year == stop_year:
            stop = 1
        elif date - datetime.timedelta(days=1) == enddate:
            stop = 1
    df = pd.DataFrame(np.array(li),columns=['SOLDDATE'])
    return df

# 테스트 데이터 이후 180일을 예측하도록 합니다.
def predict_future(model = None, df_timeseries = None, test = None):
    future = get_date(test.index[-1].date() + datetime.timedelta(1),test.index[-1].date() + datetime.timedelta(181))
    future['pred'] = 0
    future.SOLDDATE = future.SOLDDATE.astype('datetime64')
    future.set_index('SOLDDATE',inplace=True)
    past = df_timeseries.loc[future.index.to_pydatetime() - relativedelta(months = 12)]
    
    y_pred = []
    for past_ob in past.values:
        fc = forecast_one_step(model)
        y_pred.append(fc)

        ## 모형 업데이트
        model.update(past_ob[0])
    
    pred_future = pd.DataFrame(y_pred,index=future.index - datetime.timedelta(1),columns=['pred'])[1:]
    return pred_future

# 일별 날씨데이터가 담긴 데이터프레임으로부터 180일 뒤를 에측하고 데이터프레임으로 구성하도록 하는 함수입니다.
def predict_weather(df):
    columns = df.drop(['SOLDDATE'],axis=1).columns
    predicted_weather = pd.DataFrame()
    for i in columns:
        df_timeseries, train, test = makedataset(df, i)
        # adf_result = adf_test(df_timeseries)
        print(f'({i}) Started')
        model = set_model_evaluate(train, test)
        print('Predicting...')
        pred_future = predict_future(model, df_timeseries, test)
        predicted_weather[i] = pred_future['pred']
        print(f'({i}) Ended')
        print('\n')
    return predicted_weather

conn = pymysql.connect(host='34.64.224.44', user='root', password='A412GBVSDsawe%$we', db='smart_factory')
sql_state='select * from `weather_day`'
df_weather = pd.read_sql_query(sql_state, conn).drop('REGION_U',axis=1)

predicted_weather = predict_weather(df_weather)

def get_construction():
    # Connect to MariaDB Platform
    conn = pymysql.connect(host='34.64.224.44', user='root', password='A412GBVSDsawe%$we', db='smart_factory')
    sql_state='SELECT 연도, 월, 총계 FROM `building_construction_temp`'
    df=pd.read_sql_query(sql_state, conn)
    df.columns=['YEAR','MONTH','CONSTRUCTION']
    return df

def construction_dataset(df):
    df['SOLDDATE'] = datetime.datetime(2017,1,1) # 의미 없음
    for i in df.index:
        df.loc[i,'SOLDDATE'] = datetime.datetime(df.loc[i,'YEAR'],df.loc[i,'MONTH'],1)
    df.drop(['YEAR','MONTH'],axis=1,inplace=True)
    df = df.set_index('SOLDDATE')
    cutoff = round(len(df) * 0.8)
    train = df[:cutoff]
    test = df[cutoff:]
    return df, train, test

def construction_model_evaluate(train = None ,test = None, adf_result = True):
    # CONSTRUCTION도 검정 결과 정상성을 보입니다.
    print('fitting model...')
    model = auto_arima(train, start_p = 0, start_q = 0, max_p = 3, max_d = 3, max_q = 3, 
                    trace=False, stepwise = True, m = 1, seasonal=False, random_state=0, n_fits=50)
    # y_pred = []
    # for new_ob in test.values:
    #     fc = forecast_one_step(model)
    #     y_pred.append(fc)

    #     ## 모형 업데이트
    #     model.update(new_ob[0])
    # pred_new = pd.DataFrame(y_pred,index=test.index.to_pydatetime() - relativedelta(months = 1),columns=['pred'])
    #get_score(test[:-1],pred_new[1:])
    return model

def future_construction(model = None, df_timeseries = None, test = None):
    future = get_date(test.index[-1].to_pydatetime() + relativedelta(months = 1), test.index[-1].date() + relativedelta(months = 8))
    future['pred'] = 0
    future.SOLDDATE = future.SOLDDATE.astype('datetime64')
    future = future.set_index('SOLDDATE').resample('MS').mean()
    past = df_timeseries.loc[future.index.to_pydatetime() - relativedelta(months = 12)].resample('MS').mean()

    y_pred = []
    for past_ob in past.values:
        fc = forecast_one_step(model)
        y_pred.append(fc)

        ## 모형 업데이트
        model.update(past_ob[0])
    
    pred_future = pd.DataFrame(y_pred,index=future.index.to_pydatetime() - relativedelta(months = 1),columns=['CONSTRUCTION'])[1:]
    pred_future.index.name = 'SOLDDATE'
    return pred_future

def predict_construction():
    df = get_construction()
    df_timeseries, train, test = construction_dataset(df)
    # adf_result = adf_test(df_timeseries)
    # print(adf_result)
    print(f'(CONSTRUCTION) Started')
    model = construction_model_evaluate(train, test)
    print('(CONSTRUCTION) Ended')
    predicted_construction = future_construction(model, df_timeseries, test)
    return predicted_construction

def concat_all(predicted_weather = None, predicted_construction = None):
    predicted_weather['MONTH'] = predicted_weather.index.month
    predicted_weather['YEAR'] = predicted_weather.index.year
    predicted_weather = predicted_weather.reset_index()

    predicted_construction['MONTH'] = predicted_construction.index.month
    predicted_construction['YEAR'] = predicted_construction.index.year
    predicted_construction = predicted_construction.reset_index().drop('SOLDDATE',axis=1)

    predicted_variables = predicted_weather.merge(predicted_construction,on=['YEAR','MONTH'],how='left')
    predicted_variables = predicted_variables[['SOLDDATE', 'YEAR', 'MONTH', 'TEMP', 'HUM', 'RAIN', 'SNOW', 'CONSTRUCTION']]
    return predicted_variables

predicted_construction = predict_construction()
predicted_variables = concat_all(predicted_weather, predicted_construction)
print('Predict Done!')

from sqlalchemy import create_engine

db_connection_str = 'mysql+pymysql://root:A412GBVSDsawe%$we@34.64.224.44:3306/smart_factory'
db_connection = create_engine(db_connection_str)
conn = db_connection.connect()

# df_per_sql.to_sql(name = 'building_permission',con = db_connection, index = False)
predicted_variables.to_sql(name = 'predicted_variables', con = db_connection, index = False, if_exists = 'replace') # 테이블 삭제하고 새로 만들 때 사용
# df_per_sql.to_sql(name = 'building_permission',con = db_connection, index = False, if_exists = 'append') # 데이터를 추가할 때 사용

now = datetime.datetime.now().strftime('%R')
print('Pedicted Variables Update End --',now)